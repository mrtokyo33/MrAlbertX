# Nome do workflow
name: Go Continuous Integration & Delivery

# Gatilhos: Roda em pushes para o branch 'main' e em Pull Requests para 'main'
on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

# Define os jobs
jobs:
  # Job 1: Focado em qualidade de código (formatação e lint)
  lint-and-format:
    runs-on: ubuntu-latest
    steps:
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.22'
          # Habilita o cache do Go para acelerar o processo
          cache: true

      - name: Check out code
        uses: actions/checkout@v4

      - name: Check Go Formatting
        run: |
          # Verifica se algum arquivo não está formatado com 'gofmt'
          # O '!' inverte o resultado, fazendo o step falhar se houver arquivos não formatados
          if [ -n "$(gofmt -l .)" ]; then
            echo "Go files are not formatted. Please run 'gofmt -w .'"
            exit 1
          fi

      - name: Run golangci-lint
        uses: golangci/golangci-lint-action@v6
        with:
          # É opcional, mas recomendado ter um arquivo .golangci.yml na raiz do projeto
          # para configurar as regras do linter.
          version: v1.59

  # Job 2: Focado em compilar e testar em múltiplas plataformas
  build-and-test:
    # Este job só roda se o 'lint-and-format' passar com sucesso
    needs: lint-and-format
    # Define a matriz de build para rodar em múltiplos sistemas e versões do Go
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest]
        go-version: ['1.22.x']

    runs-on: ${{ matrix.os }}
    
    steps:
      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ matrix.go-version }}
          # O cache aqui é específico para cada OS e versão do Go
          cache: true

      - name: Check out code
        uses: actions/checkout@v4

      - name: Build
        # O 'go build' já baixa as dependências necessárias se o cache falhar
        run: go build -v ./...

      - name: Test
        # O '-race' é um detector de "race conditions", muito útil para código concorrente
        run: go test -v -race ./...